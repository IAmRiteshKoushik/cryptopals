use crate::utils::{
    hex::{bytes_to_hex_string, hex_to_bytes},
    xor::single_byte_xor,
};
use std::{collections::HashMap, f64};

pub fn c3() {
    let encoded_str = r"1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736";
    let ciphertest_bytes = match hex_to_bytes(encoded_str) {
        Ok(bytes) => bytes,
        Err(e) => {
            println!("Error decoding hex input: {}", e);
            return;
        }
    };

    let mut best_score = f64::NEG_INFINITY;
    let mut best_key: u8 = 0;
    let mut best_plaintext_bytes: Vec<u8> = Vec::new();

    // Iterating over all 256 possible keys (0..255)
    for key_candidate in 0..=255 {
        let candidate_plaintext_bytes = single_byte_xor(&ciphertest_bytes, key_candidate);
        let current_score = scoring_func(&candidate_plaintext_bytes);

        if current_score > best_score {
            best_score = current_score;
            best_key = key_candidate as u8;
            best_plaintext_bytes = candidate_plaintext_bytes;
        }
    }

    println!("Best Key (hex): 0x{:02x}", best_key);
    // We need to check for is_ascii_graphic because we have lots of symbols
    // within the ASCII table which cannot be represented in human readable form
    // We are technically looking only for alphanumberic and symbol characters
    // along with space as these are the only human-readable ones
    if best_key.is_ascii_graphic() || best_key == b' ' {
        println!("Best Key (char): '{}'", best_key as char);
    } else {
        println!("Best Key (non-printable)");
    }
    println!("Best Score: {:.2}", best_score); // 2 decimal point precision of float

    // Converting resulting bytes to UTF-8 string
    match String::from_utf8(best_plaintext_bytes.clone()) {
        Ok(s) => println!("Decrypted message: \n{}", s),
        Err(_) => {
            // Invalid UTF-8
            println!(
                "Decrypted message (invalid UTF-8), as bytes: {:?}",
                best_plaintext_bytes,
            );
            println!(
                "Decrypted message (invalid UTF-8), as hex: {}",
                bytes_to_hex_string(&best_plaintext_bytes),
            );
        }
    }
}

fn scoring_func(plaintext_bytes: &[u8]) -> f64 {
    let mut score: f64 = 0.0;

    // This is an arbitrary scoring mechanism generated by Gemini based on
    // frequency of characters occuring in English texts. It's basically a
    // frequency distribution statistics table
    let frequency_distro_hmap: HashMap<char, f64> = [
        (' ', 15.0), // Highest score for spaces
        ('e', 12.7),
        ('t', 9.1),
        ('a', 8.2),
        ('o', 7.5),
        ('i', 7.0),
        ('n', 6.7),
        ('s', 6.3),
        ('h', 6.1),
        ('r', 6.0),
        ('d', 4.3),
        ('l', 4.0),
        ('u', 2.8),
        ('c', 2.8),
        ('m', 2.4),
        ('w', 2.4),
        ('f', 2.2),
        ('g', 2.0),
        ('y', 2.0),
        ('p', 1.9),
        ('b', 1.5),
        ('v', 1.0),
        ('k', 0.8),
        ('j', 0.2),
        ('x', 0.2),
        ('q', 0.1),
        ('z', 0.1),
    ]
    .iter()
    .cloned()
    .collect();

    // The collect() method is constructing a HashMap from an array of tuples
    // So, an iterator is invoked which has references to the elements of the
    // tuple but these are borrowed and not owned. In-order to gain ownership
    // we need an iterator which yields owned values.
    // If .cloned() is not passed then we would be get: HashMap<&(char, f64),_>
    // by the collect function and not the entire underlying element

    for &byte in plaintext_bytes {
        // Non-ASCII printable range incurs a negative score as punishment
        if byte < 0x20 || byte > 0x7e {
            // Control bytes are excused
            if byte == b'\n' || byte == b'\t' || byte == b'\r' {
                score += 0.5;
            } else {
                score -= 0.5;
            }
        } else {
            let ch = (byte as char).to_ascii_lowercase();
            // If the character is not in the map, then default to a massive
            // Otherwise, find the score and use it
            score += frequency_distro_hmap.get(&ch).unwrap_or(&(-5.0));
        }
    }
    score
}
